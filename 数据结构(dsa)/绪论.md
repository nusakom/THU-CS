# 数据结构绪论

数据结构（C++语言版）课件:https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/index.htm

清华oj:https://dsa.cs.tsinghua.edu.cn/oj/

代码在线浏览:https://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/
## 算法
1. 计算 = 信息处理 = 借助某种工具，遵照一定规则，以明确而机械的形式进行
2. 计算模型 = 计算机 = 信息处理工具
3. 所谓算法，即特定计算模型下，旨在解决特定问题的指令序列

    输入 待处理的信息（问题）

    输出 经处理的信息（答案）

正确性 的确可以解决指定的问题

确定性 可描述为一个由基本操作组成的序列 //加盐少许，加糖适量，煮至半熟...

可行性 每一基本操作都可实现，且在常数时间内完成 //把大象放进冰箱，不过三步...”

有穷性 对于任何输入，经有穷次基本操作，都可以得到输出
## 正确的算法 ~ 好的算法
符合语法，能够编译、链接

能够正确处理简单的输入

能够正确处理大规模的输入

能够正确处理一般性的输入

能够正确处理退化的输入

能够正确处理任意合法的输入
### 健壮性： 能辨别不合法的输入并做适当处理
而不致非正常退出
### 可读性： 结构化 + 准确命名 + 注释 + ...
### 效率： 速度尽可能快
### Niklaus Wirth 公式
第一个公式：

```
Algorithms + Data Structures = Programs
```

出自 **Niklaus Wirth**（Pascal 语言之父）的书《Algorithms + Data Structures = Programs》，核心思想是：

* 一个程序 = 算法（逻辑） + 数据结构（组织形式）
* 算法决定 **做什么、怎么做**
* 数据结构决定 **数据怎么存、怎么取**
  两者结合起来，才是真正的程序。

---

第二个公式：

```
(Algorithms + Data Structures) × Efficiency = Computation
```

这是对 Wirth 公式的扩展：

* 单有程序还不够，效率（Efficiency）决定了计算是否 **可行、可扩展、可应用**。
* 这里的效率不仅仅是时间复杂度，也包括空间复杂度、并行化能力、硬件利用率。
* 没有效率优化的程序，可能在理论上正确，但在实践中无法运行（比如复杂度太高）。

换句话说：

* **程序**是算法和数据结构的组合
* **计算**是在此基础上乘以效率的产物

就像：

* 程序 = “能跑”
* 计算 = “能跑得好”

---
### 特定问题 + 不同算法
同一问题通常有多种算法，如何评判其优劣？

  实验统计是最直接的方法，但并不足以准确反映算法的真正效率
- 不同的算法，可能更适应于不同规模的输入
- 不同的算法，可能更适应于不同类型的输入
- 同一算法，可能由不同程序员、用不同程序语言、经不同编译器生成
- 同一算法，可能实现并运行于不同的体系结构、操作系统...

  为给出客观的评判，需要抽象出一个理想的平台或模型

- 不再依赖于上述种种具体的因素
- 从而直接而准确地描述、测量并评价算法
## 1.1 图灵机 
**图灵机（Turing Machine）**

图灵机是英国数学家 **艾伦·图灵（Alan Turing）** 在 1936 年提出的一种理想化的计算模型。
它并不是一台真正的机器，而是一个数学模型，用来形式化地描述“计算”这一概念。
图灵机的提出奠定了 **计算机科学的理论基础**，尤其是可计算性与复杂性理论。

---

## 2. 图灵机的组成

一台图灵机由以下几个部分构成：

1. **无限长的纸带（Tape）**

   * 纸带分为一个个格子，每个格子可以存放一个符号（通常是 0、1 或空格符号）。
   * 纸带既是输入介质，也是存储和输出介质。

2. **读写头（Head）**

   * 读写头可以在纸带上左右移动。
   * 它能读取当前格子的符号，也能在格子中写入新符号。

3. **状态寄存器（State Register）**

   * 存储图灵机的“内部状态”。
   * 状态来自一个有限集合，例如 {q0, q1, q2, …}。

4. **有限状态机（Transition Function 转移函数）**

   * 决定了图灵机的“行为规则”。
   * 根据 **当前状态** 和 **读到的符号**，确定：

     1. 要写入的符号
     2. 读写头的移动方向（左/右/不动）
     3. 下一步进入的状态

---

## 3. 工作原理

运行时，图灵机的过程如下：

1. 读写头扫描纸带上的一个格子，读取符号。
2. 根据“当前状态 + 读到的符号”，查表（转移函数）。
3. 执行动作：写符号 → 移动读写头 → 切换状态。
4. 重复以上步骤，直到进入“停机状态”。

这样，图灵机就像一台按照规则“机械化计算”的设备。

---

## 4. 图灵机的意义

* **形式化计算**：图灵机给出了“什么是可计算”的严格定义。
* **图灵完备性**：如果一种系统能模拟图灵机的运算能力，就称它是“图灵完备”的（例如现代计算机、许多编程语言）。
* **可计算性理论**：图灵机帮助我们回答“哪些问题可以计算、哪些问题不可计算”，例如停机问题（不可判定）。
* **复杂性理论**：图灵机是衡量算法效率（时间复杂度、空间复杂度）的基本模型。

---

## 5. 举个简单例子

比如我们要设计一台图灵机，判断一个字符串是否全是 `1`：

* 输入：纸带上写着一串符号（如 `111` 或 `101`）。
* 规则：

  1. 如果读到 `1`，继续向右移动。
  2. 如果读到空格，进入“接受状态”（说明全是 `1`）。
  3. 如果读到 `0`，进入“拒绝状态”。

这样，这台图灵机就完成了“判别字符串是否只含 1”的任务。

---

## 6. 总结

* 图灵机是一个 **抽象的计算模型**。
* 组成：无限纸带 + 读写头 + 状态机 + 转移规则。
* 意义：定义了 **可计算性**，奠定了 **计算机科学理论** 的基础。
* 现代计算机在本质上都可以视为“有限内存的图灵机”。

---
好的 👍 你现在是想让我介绍 **RAM 计算模型**（即随机存取机，*Random Access Machine*），对吧？它和我们前面说的 **图灵机** 一样，都是理论计算机科学里常用的 **计算模型**。我来详细给你解释一下：

---

## RAM 计算模型（Random Access Machine）

### 1. 什么是 RAM 模型？

* **RAM 模型**是一种抽象的计算机模型，用来研究算法的效率。
* 它比图灵机更接近现代计算机，因为它假设：

  * **有无限的存储单元**（类似内存中的数组）。
  * 每个单元可以在 **常数时间 O(1)** 内被访问（随机存取）。
* 因此，RAM 模型在算法分析（尤其是时间复杂度、空间复杂度）中非常常用。

---

### 2. RAM 模型的组成

1. **存储器（Memory）**

   * 一个无限长的数组，每个位置存放一个整数。
   * 数组下标可以被快速访问，就像现代计算机的内存。

2. **寄存器（Registers）**

   * RAM 模型通常有一个特殊的“累加器寄存器”（ACC），存放当前计算的值。
   * 也可能有一些辅助寄存器。

3. **指令集（Instruction Set）**

   * RAM 模型支持类似汇编语言的基本指令，例如：

     * **LOAD x**：把内存位置 x 的值读到寄存器
     * **STORE x**：把寄存器的值写回内存位置 x
     * **ADD x**：寄存器 ← 寄存器 + 内存\[x]
     * **SUB x**：寄存器 ← 寄存器 – 内存\[x]
     * **JUMP l**：跳转到标签 l
     * **JZERO l**：如果寄存器为 0，则跳转
     * **HALT**：停机

---

### 3. 工作方式

RAM 程序运行的过程大致如下：

1. 内存最开始存放输入数据。
2. 寄存器初始为 0。
3. 按照程序指令顺序逐条执行。
4. 最终，某个内存位置或寄存器的值就是输出。

---

### 4. 一个简单例子：计算 a + b

假设输入在内存：

* `M[0] = a`
* `M[1] = b`

程序（伪代码）：

```
LOAD 0    ; ACC = M[0] = a
ADD 1     ; ACC = ACC + M[1] = a + b
STORE 2   ; M[2] = ACC
HALT      ; 停机
```

执行后：

* 输出 `a + b` 存在 `M[2]` 中。

---

### 5. RAM 模型的意义

* **更贴近现代计算机**：比图灵机更自然地描述算法。
* **算法分析工具**：我们在分析算法的时间复杂度时，常常隐含地用 RAM 模型：

  * 例如，认为数组下标访问是 O(1)。
* **复杂性理论的基础**：在很多理论研究里，RAM 模型和图灵机是等价的（都能计算同样的函数），但更方便分析。

---

✅ 总结

* **图灵机**：适合研究“什么能计算”。
* **RAM 模型**：适合研究“计算要花多少时间/空间”。

---
## 1.2 大O记号,小O记号
